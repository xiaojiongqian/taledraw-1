import React, { useState, useEffect, useRef } from 'react';
import './PageItem.css';
import { safeLog } from '../utils/logger';

const PageItem = ({ 
  page, 
  index, 
  allCharacters,
  onRegenerateImage, 
  onUpdatePrompt, 
  onUpdateText,
  onUpdateTitle,
  onImageClick,
  isGenerating 
}) => {
  const [isEditingPrompt, setIsEditingPrompt] = useState(false);
  const [editedPrompt, setEditedPrompt] = useState(page.imagePrompt || '');
  const [isExpanded, setIsExpanded] = useState(false);
  const [isDetailsExpanded, setIsDetailsExpanded] = useState(false);
  const [imageLoadError, setImageLoadError] = useState(false);
  const [isEditingText, setIsEditingText] = useState(false);
  const [editedText, setEditedText] = useState(page.text || '');
  const [isEditingTitle, setIsEditingTitle] = useState(false);
  const [editedTitle, setEditedTitle] = useState(page.title || '');

  const imageRef = useRef(null);

  // Sync page prompt changes to local edit state
  useEffect(() => {
    setEditedPrompt(page.imagePrompt || '');
  }, [page.imagePrompt]);

  // Sync page text changes to local edit state
  useEffect(() => {
    setEditedText(page.text || '');
  }, [page.text]);

  // Sync page title changes to local edit state
  useEffect(() => {
    setEditedTitle(page.title || '');
  }, [page.title]);

  // Reset image load error when image URL changes
  useEffect(() => {
    setImageLoadError(false);
  }, [page.image]);

  const handleExpandClick = () => {
    if (!isExpanded) {
      // Expanding: enter edit mode
      setIsEditingPrompt(true);
      setIsExpanded(true);
    } else {
      // Collapsing: is like a cancel action
      handleCancelEdit();
    }
  };

  const handleCancelEdit = () => {
    setEditedPrompt(page.imagePrompt || ''); // Revert changes
    setIsEditingPrompt(false);
    setIsExpanded(false); // Collapse the section
  };

  const handleSaveAndRegenerate = () => {
    // First, save the prompt to the state if it has changed
    if (editedPrompt.trim() !== page.imagePrompt) {
      onUpdatePrompt(index, editedPrompt.trim());
    }
    // Then, trigger regeneration with the potentially new prompt
    const finalPrompt = editedPrompt.trim();
    onRegenerateImage(index, finalPrompt);
    
    // Collapse the section after triggering
    setIsEditingPrompt(false);
    setIsExpanded(false);
  };

  const handleTextClick = () => {
    setIsEditingText(true);
  };

  const handleTextSave = () => {
    const newText = editedText.trim();
    if (newText !== page.text) {
      onUpdateText(index, newText);
    }
    setIsEditingText(false);
  };

  const handleTextCancel = () => {
    setEditedText(page.text || '');
    setIsEditingText(false);
  };

  const handleTextKeyDown = (e) => {
    if (e.key === 'Enter' && e.ctrlKey) {
      handleTextSave();
    } else if (e.key === 'Escape') {
      handleTextCancel();
    }
  };

  const handleTitleClick = () => {
    setIsEditingTitle(true);
  };

  const handleTitleSave = () => {
    const newTitle = editedTitle.trim();
    if (newTitle !== page.title) {
      onUpdateTitle(index, newTitle);
    }
    setIsEditingTitle(false);
  };

  const handleTitleCancel = () => {
    setEditedTitle(page.title || '');
    setIsEditingTitle(false);
  };

  const handleTitleKeyDown = (e) => {
    if (e.key === 'Enter') {
      handleTitleSave();
    } else if (e.key === 'Escape') {
      handleTitleCancel();
    }
  };

  const handleImageClick = (e) => {
    if (e) {
      e.preventDefault();
      e.stopPropagation();
    }
    
    if (!page.image || imageLoadError) return;
    
    // Call the parent's image click handler
    if (onImageClick) {
      onImageClick();
    }

    // 获取原始图片文件名，避免格式转换
    const getOriginalFileName = (url) => {
      try {
        const urlObj = new URL(url);
        const pathname = urlObj.pathname;
        const fileName = pathname.split('/').pop();
        
        // 如果能获取到文件名，使用原始文件名
        if (fileName && fileName.includes('.')) {
          const baseName = fileName.split('.')[0];
          const extension = fileName.split('.').pop().toLowerCase();
          return `Page_${index + 1}_${baseName}.${extension}`;
        }
        
        // 否则根据URL推断格式
        if (url.includes('webp')) return `Page_${index + 1}_Illustration.webp`;
        if (url.includes('jpeg') || url.includes('jpg')) return `Page_${index + 1}_Illustration.jpg`;
        if (url.includes('png')) return `Page_${index + 1}_Illustration.png`;
        
        return `Page_${index + 1}_Illustration.png`;
      } catch (error) {
        return `Page_${index + 1}_Illustration.png`;
      }
    };

    const originalFileName = getOriginalFileName(page.image);
    const pageTitle = page.title ? `${index + 1}. ${page.title}` : `Page ${index + 1}`;

    // 计算窗口尺寸
    const screenWidth = window.screen.availWidth;
    const screenHeight = window.screen.availHeight;
    const windowWidth = Math.min(screenWidth * 0.9, 1200);
    const windowHeight = Math.min(screenHeight * 0.9, 800);
    const left = (screenWidth - windowWidth) / 2;
    const top = (screenHeight - windowHeight) / 2;

    // 打开新窗口
    const newWindow = window.open('', '_blank', 
      `width=${Math.round(windowWidth)},height=${Math.round(windowHeight)},left=${Math.round(left)},top=${Math.round(top)},resizable=yes,scrollbars=no,menubar=no,toolbar=no,status=no`
    );
    
    if (!newWindow) {
      safeLog.warn('Failed to open popup window - popup may be blocked');
      return;
    }

    // 使用已缓存的图片数据，避免重新下载
    const createImageViewer = () => {
      const currentImg = imageRef.current;
      let imageDataUrl = null;
      let useOriginalUrl = true;
      
      // 尝试从已加载的图片创建DataURL，避免网络请求
      if (currentImg && currentImg.complete && currentImg.naturalWidth > 0) {
        try {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = currentImg.naturalWidth;
          canvas.height = currentImg.naturalHeight;
          ctx.drawImage(currentImg, 0, 0);
          
          // 尝试保持原始格式
          let mimeType = 'image/png';
          if (page.image.includes('.jpg') || page.image.includes('.jpeg')) {
            mimeType = 'image/jpeg';
          } else if (page.image.includes('.webp')) {
            // 检查浏览器是否支持WebP
            const testCanvas = document.createElement('canvas');
            testCanvas.width = testCanvas.height = 1;
            if (testCanvas.toDataURL('image/webp').startsWith('data:image/webp')) {
              mimeType = 'image/webp';
            }
          }
          
          imageDataUrl = canvas.toDataURL(mimeType, 0.95);
          useOriginalUrl = false;
          console.log('Using cached image data for display and download');
        } catch (error) {
          console.log('Canvas failed, using original URL:', error);
          useOriginalUrl = true;
        }
      }
      
      const displayUrl = imageDataUrl || page.image;
      const downloadUrl = imageDataUrl || page.image;
      
      newWindow.document.write(`
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="UTF-8">
          <title>${pageTitle}</title>
          <style>
            * { margin: 0; padding: 0; box-sizing: border-box; }
            html, body { 
              height: 100%; 
              background: #f5f5f5; 
              overflow: auto;
              font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            }
            .container { 
              min-height: 100vh;
              display: flex; 
              align-items: center; 
              justify-content: center; 
              padding: 20px;
              position: relative;
            }
            .image-wrapper {
              position: relative;
              max-width: 100%;
              max-height: 100%;
              display: flex;
              align-items: center;
              justify-content: center;
            }
            .image { 
              max-width: 100%; 
              max-height: calc(100vh - 120px);
              height: auto;
              width: auto;
              cursor: zoom-in;
              border-radius: 8px;
              box-shadow: 0 4px 20px rgba(0,0,0,0.1);
              transition: transform 0.3s ease;
            }
            .image.zoomed {
              cursor: zoom-out;
              transform: scale(1.5);
              max-width: none;
              max-height: none;
            }
            .controls { 
              position: fixed; 
              top: 20px; 
              right: 20px; 
              display: flex; 
              gap: 10px; 
              z-index: 1000; 
            }
            .btn { 
              padding: 10px 16px; 
              border: none; 
              border-radius: 6px; 
              cursor: pointer; 
              font-size: 14px; 
              font-weight: 500;
              background: #007AFF; 
              color: white; 
              transition: all 0.2s ease;
              box-shadow: 0 2px 10px rgba(0,122,255,0.3);
            }
            .btn:hover { 
              background: #0056b3; 
              transform: translateY(-1px);
            }
            .btn.secondary {
              background: #6c757d;
            }
            .btn.secondary:hover {
              background: #545b62;
            }
            .title {
              position: fixed;
              top: 20px;
              left: 20px;
              background: rgba(0,0,0,0.7);
              color: white;
              padding: 8px 12px;
              border-radius: 4px;
              font-size: 14px;
              z-index: 1000;
            }
          </style>
        </head>
        <body>
          <div class="title">${pageTitle}</div>
          <div class="controls">
            <button class="btn" onclick="saveImage()">Save</button>
            <button class="btn secondary" onclick="closeWindow()">Close</button>
          </div>
          <div class="container">
            <div class="image-wrapper">
              <img id="mainImage" src="${displayUrl}" class="image" alt="${pageTitle}" ondblclick="toggleZoom()" />
            </div>
          </div>
          <script>
            const downloadUrl = '${downloadUrl}';
            const fileName = '${originalFileName}';
            const isDataUrl = '${!useOriginalUrl}' === 'true';
            
            let isZoomed = false;
            
            function toggleZoom() {
              const img = document.getElementById('mainImage');
              isZoomed = !isZoomed;
              if (isZoomed) {
                img.classList.add('zoomed');
              } else {
                img.classList.remove('zoomed');
              }
            }
            
            function saveImage() {
              console.log('Saving image:', fileName, 'Using data URL:', isDataUrl);
              
              if (isDataUrl && downloadUrl.startsWith('data:')) {
                // 使用DataURL下载，避免跨域问题
                try {
                  const link = document.createElement('a');
                  link.href = downloadUrl;
                  link.download = fileName;
                  link.style.display = 'none';
                  
                  document.body.appendChild(link);
                  link.click();
                  document.body.removeChild(link);
                  
                  console.log('Download triggered successfully using DataURL');
                } catch (error) {
                  console.error('DataURL download failed:', error);
                  fallbackDownload();
                }
              } else {
                // 跨域URL，使用fetch + blob下载
                fetchAndDownload();
              }
            }
            
            function fetchAndDownload() {
              console.log('Attempting fetch download for cross-origin image');
              
              fetch(downloadUrl, {
                mode: 'cors',
                credentials: 'omit'
              })
              .then(response => {
                if (!response.ok) {
                  throw new Error('Network response was not ok');
                }
                return response.blob();
              })
              .then(blob => {
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = fileName;
                link.style.display = 'none';
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // 清理blob URL
                setTimeout(() => URL.revokeObjectURL(url), 100);
                console.log('Download completed via fetch + blob');
              })
              .catch(error => {
                console.error('Fetch download failed:', error);
                fallbackDownload();
              });
            }
            
            function fallbackDownload() {
              console.log('Using fallback download method');
              
              // 方法1: 尝试在新标签页中打开并提示用户手动保存
              const downloadLink = document.createElement('a');
              downloadLink.href = downloadUrl;
              downloadLink.target = '_blank';
              downloadLink.rel = 'noopener noreferrer';
              
              // 尝试强制下载
              downloadLink.download = fileName;
              
              document.body.appendChild(downloadLink);
              downloadLink.click();
              document.body.removeChild(downloadLink);
              
              // 给用户提示
              setTimeout(() => {
                alert('If download did not start automatically, please:\\n\\n1. Right-click on the image\\n2. Select "Save image as..."\\n3. Choose your desired location');
              }, 1000);
            }
            
            function closeWindow() {
              window.close();
            }
            
            // 键盘快捷键
            document.addEventListener('keydown', function(e) {
              if (e.key === 'Escape') {
                closeWindow();
              } else if (e.key === 's' && (e.ctrlKey || e.metaKey)) {
                e.preventDefault();
                saveImage();
              }
            });
          </script>
        </body>
        </html>
      `);
    };
    
    createImageViewer();
    
    newWindow.document.close();
    
    // 聚焦到新窗口
    newWindow.focus();
  };

  const handleImageLoadError = () => {
    setImageLoadError(true);
  };

  const handleReloadImage = () => {
    setImageLoadError(false);
    // Force reload by changing the image src with a cache-busting parameter
    const img = new Image();
    img.onload = () => {
      setImageLoadError(false);
    };
    img.onerror = () => {
      setImageLoadError(true);
    };
    img.src = page.image + '?reload=' + Date.now();
  };

  const getStatusText = () => {
    switch (page.status) {
      case 'success':
        return 'Generated Successfully';
      case 'error':
        return 'Generation Failed';
      case 'generating':
      case 'regenerating':
        return 'Generating...';
      case 'pending':
        return 'Ready to Generate';
      default:
        return 'Unknown Status';
    }
  };

  // 获取错误类型的显示文本
  const getErrorTypeText = (errorType) => {
    switch (errorType) {
      case 'safety_filter':
        return 'Content Filtered';
      case 'timeout':
        return 'Generation Timeout';
      case 'quota':
        return 'API Quota Exceeded';
      case 'auth':
        return 'Authentication Error';
      case 'permission':
        return 'Permission Denied';
      case 'server':
        return 'Server Error';
      default:
        return 'Generation Failed';
    }
  };

  // 获取错误类型的图标
  const getErrorIcon = (errorType) => {
    switch (errorType) {
      case 'safety_filter':
        return '🛡️';
      case 'timeout':
        return '⏱️';
      case 'quota':
        return '📊';
      case 'auth':
        return '🔐';
      case 'permission':
        return '🚫';
      case 'server':
        return '⚠️';
      default:
        return '❌';
    }
  };

  // 获取模型显示名称
  const getModelDisplayName = (model) => {
    switch (model) {
      case 'imagen4-fast':
        return 'Imagen 4 Fast';
      case 'imagen4':
        return 'Imagen 4';
      case 'imagen3':
        return 'Imagen 3';
      default:
        return model || 'Unknown Model';
    }
  };

  return (
    <div className={`page-item ${page.status || 'unknown'}`}>
      <div className="page-header">
        <div className="page-number">
          {isEditingTitle ? (
            <div className="title-editor">
              <input
                type="text"
                value={editedTitle}
                onChange={(e) => setEditedTitle(e.target.value)}
                onKeyDown={handleTitleKeyDown}
                className="title-input"
                placeholder="Enter page title..."
                autoFocus
              />
              <div className="title-editor-actions">
                <button 
                  className="btn btn-primary title-save-btn"
                  onClick={handleTitleSave}
                >
                  Save
                </button>
                <button 
                  className="btn btn-secondary title-cancel-btn"
                  onClick={handleTitleCancel}
                >
                  Cancel
                </button>
              </div>
            </div>
          ) : (
            <div
              className="editable-page-title"
              onClick={handleTitleClick}
              title="Click to edit title"
            >
              {page.title ? `${index + 1}. ${page.title}` : `${index + 1}.`}
            </div>
          )}
        </div>
        <div className="page-status">
          <span className={`status-badge ${page.status || 'unknown'}`}>
            {getStatusText()}
          </span>
        </div>
      </div>
      
      <div className="page-content">
        <div className="page-text">
          {isEditingText ? (
            <div className="text-editor">
              <textarea
                value={editedText}
                onChange={(e) => setEditedText(e.target.value)}
                onKeyDown={handleTextKeyDown}
                rows={4}
                className="text-textarea"
                placeholder="Enter page text..."
                autoFocus
              />
              <div className="text-editor-actions">
                <button 
                  className="btn btn-primary text-save-btn"
                  onClick={handleTextSave}
                >
                  Save
                </button>
                <button 
                  className="btn btn-secondary text-cancel-btn"
                  onClick={handleTextCancel}
                >
                  Cancel
                </button>
              </div>
            </div>
          ) : (
            <p 
              className="editable-text"
              onClick={handleTextClick}
              title="Click to edit text"
            >
              {page.text}
            </p>
          )}
        </div>
        
        <div className="page-image">
          {page.status === 'regenerating' ? (
            <div className="image-generating">
              <div className="generating-message-box">
                <div className="loading-spinner"></div>
                <p className="generating-title">Regenerating...</p>
                <small className="generating-subtitle">Please wait</small>
              </div>
            </div>
          ) : page.status === 'generating' ? (
            <div className="image-generating">
              <div className="generating-message-box">
                <div className="loading-spinner"></div>
                <p className="generating-title">Generating image...</p>
                <small className="generating-subtitle">Please wait, creating beautiful illustrations for you</small>
              </div>
            </div>
          ) : page.status === 'error' ? (
            <div className="image-error">
              <div className="error-message-box">
                <div className="error-icon">{getErrorIcon(page.errorType)}</div>
                <p className="error-title">{getErrorTypeText(page.errorType)}</p>
                {page.errorDetails && (
                  <p className="error-detail">{page.errorDetails}</p>
                )}
                {page.model && (
                  <p className="error-model">Model: {getModelDisplayName(page.model)}</p>
                )}
                <button 
                  className="regenerate-button"
                  onClick={handleSaveAndRegenerate}
                  disabled={isGenerating}
                >
                  Regenerate
                </button>
              </div>
            </div>
          ) : page.image ? (
            <div className="image-container">
              {imageLoadError ? (
                <div className="image-load-error">
                  <div className="error-message-box">
                    <p className="error-title">Image Load Failed</p>
                    <p className="error-detail">Failed to load image. Please try reloading.</p>
                    <button 
                      className="reload-button"
                      onClick={handleReloadImage}
                    >
                      Reload Image
                    </button>
                  </div>
                </div>
              ) : (
                <>
                  <img 
                    ref={imageRef}
                    src={page.image} 
                    alt={`${index + 1}. Illustration`}
                    onClick={handleImageClick}
                    onError={handleImageLoadError}
                    className="clickable-image"
                    title="Click to open in new window"
                  />
                  {page.model && process.env.NODE_ENV === 'development' && (
                    <div className="image-model-badge">
                      {getModelDisplayName(page.model)}
                    </div>
                  )}
                </>
              )}
            </div>
          ) : (
            <div className="image-pending">
              <div className="pending-message-box">
                <p className="pending-title">Waiting to generate</p>
                <button 
                  className="regenerate-button"
                  onClick={handleSaveAndRegenerate}
                  disabled={isGenerating}
                >
                  Generate Image
                </button>
              </div>
            </div>
          )}
        </div>
      </div>
      
      {page.imagePrompt && (
        <div className="image-prompt-section">
          <div className="prompt-header">
            <button 
              className="expand-button"
              onClick={handleExpandClick}
            >
              {isExpanded ? 'Hide Prompt' : 'Prompt'}
            </button>
          </div>
          
          {isExpanded && (
            <div className="prompt-content">
              <div className="prompt-editor">
                <textarea
                  value={editedPrompt}
                  onChange={(e) => setEditedPrompt(e.target.value)}
                  rows={4}
                  placeholder="Enter image generation prompt..."
                  className="prompt-textarea"
                />
                <div className="editor-actions">
                  <button 
                    className="btn btn-primary"
                    onClick={handleSaveAndRegenerate}
                    disabled={isGenerating}
                  >
                    Save and Regenerate
                  </button>
                  <button 
                    className="btn btn-secondary"
                    onClick={handleCancelEdit}
                  >
                    Cancel
                  </button>
                </div>
              </div>
            </div>
          )}
        </div>
      )}
      
      {/* 只在开发环境显示Scene和Characters详情 */}
      {process.env.NODE_ENV === 'development' && (page.sceneType || (page.sceneCharacters && page.sceneCharacters.length > 0)) && (
        <div className="details-section">
          <div 
            className="details-header" 
            onClick={() => setIsDetailsExpanded(!isDetailsExpanded)}
            style={{ cursor: 'pointer', display: 'flex', alignItems: 'center', padding: '8px 0' }}
          >
            <small>
              {page.sceneType && <span className="scene-type">Scene: {page.sceneType}</span>}
              {page.sceneCharacters && page.sceneCharacters.length > 0 && (
                <span className="scene-characters"> | Characters: {page.sceneCharacters.join(', ')}</span>
              )}
            </small>
          </div>

          {isDetailsExpanded && (
            <div className="details-content" style={{ marginTop: '8px', paddingLeft: '24px', borderLeft: '2px solid #f0f0f0', marginLeft: '4px'}}>
              {page.scenePrompt && (
                <div className="prompt-display" style={{ marginBottom: '12px' }}>
                  <strong style={{ display: 'block', marginBottom: '4px', color: '#333' }}>Scene Prompt:</strong>
                  <p style={{ margin: 0, whiteSpace: 'pre-wrap', fontSize: '0.9em', color: '#666' }}>{page.scenePrompt}</p>
                </div>
              )}

              {page.sceneCharacters && page.sceneCharacters.length > 0 && (
                <div className="character-details">
                  <strong style={{ display: 'block', marginBottom: '8px', color: '#333' }}>Character Details:</strong>
                  {page.sceneCharacters.map(characterName => {
                    // 尝试精确匹配和模糊匹配
                    let character = allCharacters[characterName];
                    
                    // 如果精确匹配失败，尝试模糊匹配
                    if (!character) {
                      const availableNames = Object.keys(allCharacters);
                      const fuzzyMatch = availableNames.find(name => 
                        name.includes(characterName) || 
                        characterName.includes(name) ||
                        name.toLowerCase().includes(characterName.toLowerCase()) ||
                        characterName.toLowerCase().includes(name.toLowerCase())
                      );
                      if (fuzzyMatch) {
                        character = allCharacters[fuzzyMatch];
                      }
                    }
                    
                    if (!character) {
                      return (
                        <div key={characterName} style={{ marginBottom: '12px', padding: '8px', background: '#f9f9f9', border: '1px solid #ddd', borderRadius: '4px' }}>
                          <h4 style={{ margin: '0 0 8px 0', color: '#666' }}>{characterName}</h4>
                          <div style={{ fontSize: '0.9em', color: '#999' }}>Character details not available</div>
                        </div>
                      );
                    }
                    return (
                      <div key={characterName} style={{ marginBottom: '12px', paddingLeft: '12px' }}>
                        <p style={{ margin: 0, fontWeight: 'bold', color: '#555' }}>{characterName}</p>
                        <ul style={{ margin: 0, paddingLeft: '20px', listStyleType: 'disc' }}>
                          {character.appearance && <li style={{ fontSize: '0.9em', color: '#666' }}><strong>Appearance:</strong> {character.appearance}</li>}
                          {character.clothing && <li style={{ fontSize: '0.9em', color: '#666' }}><strong>Clothing:</strong> {character.clothing}</li>}
                          {character.personality && <li style={{ fontSize: '0.9em', color: '#666' }}><strong>Personality:</strong> {character.personality}</li>}
                        </ul>
                      </div>
                    );
                  })}
                </div>
              )}
              
              {(!page.scenePrompt && (!page.sceneCharacters || page.sceneCharacters.length === 0)) && (
                  <p style={{ margin: 0, color: '#888', fontSize: '0.9em' }}>No available prompts or character details.</p>
              )}
            </div>
          )}
        </div>
      )}

    </div>
  );
};

export default PageItem; 